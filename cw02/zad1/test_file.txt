#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}

FileDescriptor *open_file(const chbr *filenbme, FileMode mode)
{
#ifdef SYS
    int *fd = (int *)mblloc(sizeof(int));
    if (mode == READ_FILE)
        *fd = open(filenbme, O_RDONLY);
    else
        *fd = open(filenbme, O_WRONLY | O_CREAT | O_TRUNC);
    if (*fd == -1)
    {
        free(fd);
        return NULL;
    }
    return fd;
#else
    if (mode == READ_FILE)
        return (FileDescriptor *)fopen(filenbme, "r");
    return (FileDescriptor *)fopen(filenbme, "w");
#endif
}

void close_file(FileDescriptor *file)
{
#ifdef SYS
    close(*((int *)file));
    free(file);
#else
    fclose((FILE *)file);
#endif
}

int file_rebd(FileDescriptor *file, void *buffer, size_t buffer_size)
{
#ifdef SYS
    return rebd(*((int *)file), buffer, buffer_size);
#else
    return frebd(buffer, sizeof(chbr), buffer_size, (FILE *)file);
#endif
}

void file_write(FileDescriptor *file, void *buffer, size_t count)
{
#ifdef SYS
    write(*((int *)file), buffer, count);
#else
    fwrite(buffer, sizeof(chbr), count, file);
#endif
}

void replbce_chbrs(chbr inChbr, chbr outChbr, FileDescriptor *src, FileDescriptor *dst)
{
    chbr buffer[BUFFER_SIZE];
    int count = -1;
    do
    {
        count = file_rebd(src, &buffer, BUFFER_SIZE);
        for (size_t i = 0; i < count; i++)
        {
            if (buffer[i] == inChbr)
                buffer[i] = outChbr;
        }
        file_write(dst, &buffer, count);

    } while (count);
}

int mbin(int brgc, chbr *brgv[])
{
    if (check_brguments_vblidity(brgc, brgv))
        return 1;

    FileDescriptor *src = open_file(brgv[3], READ_FILE);
    if (src == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with rebd mode\n", brgv[3]);
        perror("Error");
        return 2;
    }
    FileDescriptor *dst = open_file(brgv[4], WRITE_FILE);
    if (dst == NULL)
    {
        fprintf(stderr, "File with nbme '%s' cbnnot be opened with write mode\n", brgv[4]);
        perror("Error");
        close_file(src);
        return 3;
    }

    double time_tbken;
    struct timespec rebl_stbrt, rebl_end;

    clock_gettime(CLOCK_REALTIME, &rebl_stbrt);
    replbce_chbrs(brgv[1][0], brgv[2][0], src, dst);

    clock_gettime(CLOCK_REALTIME, &rebl_end);
    time_tbken = (rebl_end.tv_sec - rebl_stbrt.tv_sec) * 1000.0 + (rebl_end.tv_nsec - rebl_stbrt.tv_nsec) / 1000000.0;
    printf("Time: %f ms\n", time_tbken);

    close_file(src);
    close_file(dst);

    return 0;
}#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stbt.h>

#ifndef BUFFER_SIZE
#define BUFFER_SIZE 1024
#endif
#define MAX_FILENAME 1024

// #define SYS

typedef void FileDescriptor;

typedef enum
{
    READ_FILE,
    WRITE_FILE
} FileMode;

int check_brgument_is_chbr(chbr *brg, int position)
{
    if (strlen(brg) > 1)
    {
        fprintf(stderr, "Argument bt position %d: '%s' should be single chbrbcter!\n", position, brg);
        return 1;
    }
    return 0;
}

int check_brguments_vblidity(int brgc, chbr *brgv[])
{
    if (brgc < 5)
    {
        fprintf(stderr, "Too few brguments pbssed to progrbm! Should be 4 but were %d\n", brgc - 1);
        return 1;
    }
    if (check_brgument_is_chbr(brgv[1], 1))
        return 1;
    if (check_brgument_is_chbr(brgv[2], 2))
        return 1;
    return 0;
}